<!DOCTYPE html>
<html lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title>面试指南</title>
  <meta name="description" content="面试指南" />
  <meta name="generator" content="bookdown 0.19 and GitBook 2.6.7" />

  <meta property="og:title" content="面试指南" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="面试指南" />
  
  
  

<meta name="author" content="高文欣" />


<meta name="date" content="2020-10-21" />

  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  


<script src="libs/header-attrs-2.2/header-attrs.js"></script>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="0.1" data-path=""><a href="#不重复两数之和的问题"><i class="fa fa-check"></i><b>0.1</b> 不重复两数之和的问题</a></li>
<li class="chapter" data-level="0.2" data-path=""><a href="#不重复三数之和问题"><i class="fa fa-check"></i><b>0.2</b> 不重复三数之和问题</a></li>
<li class="chapter" data-level="0.3" data-path=""><a href="#最长子序列问题1"><i class="fa fa-check"></i><b>0.3</b> 最长子序列问题1</a></li>
<li class="chapter" data-level="0.4" data-path=""><a href="#最长子序列问题2"><i class="fa fa-check"></i><b>0.4</b> 最长子序列问题2</a></li>
<li class="chapter" data-level="0.5" data-path=""><a href="#最长子序列问题3"><i class="fa fa-check"></i><b>0.5</b> 最长子序列问题3</a></li>
<li class="chapter" data-level="0.6" data-path=""><a href="#最长子序列问题4"><i class="fa fa-check"></i><b>0.6</b> 最长子序列问题4</a></li>
<li class="chapter" data-level="0.7" data-path=""><a href="#最长子序列5"><i class="fa fa-check"></i><b>0.7</b> 最长子序列5</a></li>
<li class="chapter" data-level="0.8" data-path=""><a href="#最长可整合子数组的长度"><i class="fa fa-check"></i><b>0.8</b> 最长可整合子数组的长度</a></li>
<li class="chapter" data-level="0.9" data-path=""><a href="#背包问题"><i class="fa fa-check"></i><b>0.9</b> 背包问题</a></li>
<li class="chapter" data-level="0.10" data-path=""><a href="#零钱兑换问题"><i class="fa fa-check"></i><b>0.10</b> 零钱兑换问题</a></li>
<li class="chapter" data-level="0.11" data-path=""><a href="#求最大子矩阵的大小"><i class="fa fa-check"></i><b>0.11</b> 求最大子矩阵的大小</a></li>
<li class="chapter" data-level="0.12" data-path=""><a href="#换钱的方法"><i class="fa fa-check"></i><b>0.12</b> 换钱的方法</a></li>
<li class="chapter" data-level="0.13" data-path=""><a href="#二分法查找"><i class="fa fa-check"></i><b>0.13</b> 二分法查找</a></li>
<li class="chapter" data-level="0.14" data-path=""><a href="#二叉树的先序中序后序遍历"><i class="fa fa-check"></i><b>0.14</b> 二叉树的先序中序后序遍历</a></li>
<li class="chapter" data-level="0.15" data-path=""><a href="#机器人到达指定位置的方法数"><i class="fa fa-check"></i><b>0.15</b> 机器人到达指定位置的方法数</a></li>
<li class="chapter" data-level="0.16" data-path=""><a href="#打气球的最大分数"><i class="fa fa-check"></i><b>0.16</b> 打气球的最大分数</a></li>
<li class="chapter" data-level="0.17" data-path=""><a href="#维特比算法"><i class="fa fa-check"></i><b>0.17</b> 维特比算法</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">面试指南</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="header">
<h1 class="title">面试指南</h1>
<p class="author"><em>高文欣</em></p>
<p class="date"><em>2020-10-21</em></p>
</div>
<div id="不重复两数之和的问题" class="section level2" number="0.1">
<h2><span class="header-section-number">0.1</span> 不重复两数之和的问题</h2>
<p>题目描述
给定排序数组arr和整数k，不重复打印arr中所有相加和为k的不降序二元组
例如, arr = [-8, -4, -3, 0, 1, 2, 4, 5, 8, 9], k = 10，打印结果为：
1, 9
2, 8
[要求]
时间复杂度为O(n)O(n)，空间复杂度为O(1)O(1)
输入描述:
第一行有两个整数n, k
接下来一行有n个整数表示数组内的元素</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1"></a><span class="co">#接收用户输入的两个整数</span></span>
<span id="cb1-2"><a href="#cb1-2"></a>n,k <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>,<span class="bu">input</span>().split())</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="co">#将n个整数存放到列表中</span></span>
<span id="cb1-4"><a href="#cb1-4"></a>ls <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>,<span class="bu">input</span>().split()))</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="co">#先排个序，不用排序，因为是有序数组</span></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="co">#ls.sort() </span></span>
<span id="cb1-7"><a href="#cb1-7"></a><span class="co">#i,j赋初值，从首尾开始向中间遍历</span></span>
<span id="cb1-8"><a href="#cb1-8"></a>i, j <span class="op">=</span> <span class="dv">0</span>, n<span class="op">-</span><span class="dv">1</span></span>
<span id="cb1-9"><a href="#cb1-9"></a><span class="cf">while</span> i <span class="op">&lt;</span> j:</span>
<span id="cb1-10"><a href="#cb1-10"></a>    <span class="cf">if</span> ls[i]<span class="op">+</span>ls[j] <span class="op">&lt;</span> k: <span class="co">#小于k,i向后</span></span>
<span id="cb1-11"><a href="#cb1-11"></a>        i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>    <span class="cf">elif</span> ls[i]<span class="op">+</span>ls[j] <span class="op">==</span> k: <span class="co">#当存在一个形如（1 9）的组合时，跳过1之后的1和9之前的9</span></span>
<span id="cb1-13"><a href="#cb1-13"></a>        <span class="bu">print</span>(ls[i], ls[j])</span>
<span id="cb1-14"><a href="#cb1-14"></a>        <span class="cf">while</span> ls[i]<span class="op">==</span>ls[i<span class="op">+</span><span class="dv">1</span>]:</span>
<span id="cb1-15"><a href="#cb1-15"></a>            i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>        <span class="cf">while</span> ls[j] <span class="op">==</span> ls[j<span class="op">-</span><span class="dv">1</span>]:</span>
<span id="cb1-17"><a href="#cb1-17"></a>            j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>        <span class="co">#有重复则跳过，同时i,j向中间收缩</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>        i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-20"><a href="#cb1-20"></a>        j <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb1-21"><a href="#cb1-21"></a>    <span class="cf">else</span>: <span class="co">#大于k,j向前</span></span>
<span id="cb1-22"><a href="#cb1-22"></a>        j <span class="op">-=</span> <span class="dv">1</span></span></code></pre></div>
<p><strong>这两道题都是在考滑动窗口，需要知道滑动窗口怎样移动</strong></p>
</div>
<div id="不重复三数之和问题" class="section level2" number="0.2">
<h2><span class="header-section-number">0.2</span> 不重复三数之和问题</h2>
<p>题目描述
给定排序数组arr和整数k，不重复打印arr中所有相加和为k的严格升序的三元组
例如, arr = [-8, -4, -3, 0, 1, 2, 4, 5, 8, 9], k = 10，打印结果为：
-4 5 9
-3 4 9
-3 5 8
0 1 9
0 2 8
1 4 5
[要求]
时间复杂度为O(n^2)O(n
2
)，空间复杂度为O(1)O(1)</p>
<p>输入描述:
第一行有两个整数n, k
接下来一行有n个整数表示数组内的元素
输出描述:
输出若干行，每行三个整数表示答案
按三元组从小到大的顺序输出(三元组大小比较方式为每个依次比较三元组内每个数)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a></span>
<span id="cb2-2"><a href="#cb2-2"></a>class Solution<span class="op">:</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="st">    </span>def <span class="kw">threeSumEqualtoK</span>(self , arr , k )<span class="op">:</span></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="st">        </span><span class="cf">if</span> arr is None or <span class="kw">len</span>(arr) <span class="op">&lt;</span><span class="st"> </span><span class="dv">3</span><span class="op">:</span></span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="st">            </span>return</span>
<span id="cb2-7"><a href="#cb2-7"></a>        </span>
<span id="cb2-8"><a href="#cb2-8"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(arr)<span class="op">-</span><span class="dv">2</span>)<span class="op">:</span></span>
<span id="cb2-9"><a href="#cb2-9"></a><span class="st">            </span><span class="cf">if</span> arr[i] <span class="op">==</span><span class="st"> </span>arr[i <span class="op">+</span><span class="st"> </span><span class="dv">1</span>]<span class="op">:</span><span class="st">  </span><span class="co"># 开头去重</span></span>
<span id="cb2-10"><a href="#cb2-10"></a><span class="st">                </span>continue</span>
<span id="cb2-11"><a href="#cb2-11"></a>            Left =<span class="st"> </span>i <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>            Right =<span class="st"> </span><span class="kw">len</span>(arr) <span class="op">-</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb2-13"><a href="#cb2-13"></a>            <span class="cf">while</span> Left <span class="op">&lt;</span><span class="st"> </span>Right<span class="op">:</span></span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="st">                </span><span class="cf">if</span> arr[i] <span class="op">+</span><span class="st"> </span>arr[Left] <span class="op">+</span><span class="st"> </span>arr[Right] <span class="op">==</span><span class="st"> </span>k<span class="op">:</span></span>
<span id="cb2-15"><a href="#cb2-15"></a><span class="st">                    </span><span class="kw">print</span>(arr[i],arr[Left],arr[Right])</span>
<span id="cb2-16"><a href="#cb2-16"></a>                    <span class="cf">while</span> arr[Left] <span class="op">==</span><span class="st"> </span>arr[Left <span class="op">+</span><span class="st"> </span><span class="dv">1</span>]<span class="op">:</span><span class="st">  </span><span class="co"># 结果去重</span></span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="st">                        </span>Left <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb2-18"><a href="#cb2-18"></a>                    <span class="cf">while</span> arr[Right] <span class="op">==</span><span class="st"> </span>arr[Right <span class="op">-</span><span class="st"> </span><span class="dv">1</span>]<span class="op">:</span><span class="st">  </span><span class="co"># 结果去重</span></span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="st">                        </span>Right <span class="op">-</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb2-20"><a href="#cb2-20"></a>                    Left <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>                    Right <span class="op">-</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb2-22"><a href="#cb2-22"></a>                elif arr[i] <span class="op">+</span><span class="st"> </span>arr[Left] <span class="op">+</span><span class="st"> </span>arr[Right] <span class="op">&gt;</span><span class="st"> </span>k<span class="op">:</span></span>
<span id="cb2-23"><a href="#cb2-23"></a><span class="st">                    </span>Right <span class="op">-</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb2-24"><a href="#cb2-24"></a>                <span class="cf">else</span><span class="op">:</span></span>
<span id="cb2-25"><a href="#cb2-25"></a><span class="st">                    </span>Left <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb2-26"><a href="#cb2-26"></a></span>
<span id="cb2-27"><a href="#cb2-27"></a>    </span>
<span id="cb2-28"><a href="#cb2-28"></a><span class="cf">if</span> __name__ <span class="op">==</span><span class="st"> &#39;__main__&#39;</span><span class="op">:</span></span>
<span id="cb2-29"><a href="#cb2-29"></a><span class="st">    </span>n, k =<span class="st"> </span><span class="kw">list</span>(<span class="kw">map</span>(int, <span class="kw">input</span>()<span class="kw">.split</span>()))</span>
<span id="cb2-30"><a href="#cb2-30"></a>    arr =<span class="st"> </span><span class="kw">list</span>(<span class="kw">map</span>(int, <span class="kw">input</span>()<span class="kw">.split</span>()))</span>
<span id="cb2-31"><a href="#cb2-31"></a>    solution =<span class="st"> </span><span class="kw">Solution</span>()</span>
<span id="cb2-32"><a href="#cb2-32"></a>    <span class="kw">solution.threeSumEqualtoK</span>(arr, k)</span></code></pre></div>
</div>
<div id="最长子序列问题1" class="section level2" number="0.3">
<h2><span class="header-section-number">0.3</span> 最长子序列问题1</h2>
<p><em>题目描述</em>
给定一个无序数组arr，其中元素可正、可负、可0。求arr所有子数组中正数与负数个数相等的最长子数组的长度。
[要求]
时间复杂度为O(n)，空间复杂度为O(n)</p>
<p>输入描述:
第一行一个整数N，表示数组长度
接下来一行有N个数表示数组中的数
输出描述:
输出一个整数表示答案</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1"></a>N<span class="op">=</span> <span class="bu">int</span>(<span class="bu">input</span>())</span>
<span id="cb3-2"><a href="#cb3-2"></a>arr <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>,<span class="bu">input</span>().split()))</span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co"># 与上一题类似，这里相当于将正数看做+1，负数看做-1。计算总和为0的最长子数组长度。</span></span>
<span id="cb3-4"><a href="#cb3-4"></a></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="op">&lt;!--</span> 我觉得还是记下来比较好，可以做一个对比哇,但是感觉题目描述的很有问题 <span class="op">--&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6"></a>sums <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-7"><a href="#cb3-7"></a>dic <span class="op">=</span> {<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>}</span>
<span id="cb3-8"><a href="#cb3-8"></a>ans <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb3-10"><a href="#cb3-10"></a>    <span class="cf">if</span> arr[i]<span class="op">&gt;</span><span class="dv">0</span>:</span>
<span id="cb3-11"><a href="#cb3-11"></a>        sums <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb3-12"><a href="#cb3-12"></a>    <span class="cf">elif</span> arr[i]<span class="op">&lt;</span><span class="dv">0</span>:</span>
<span id="cb3-13"><a href="#cb3-13"></a>        sums <span class="op">-=</span> <span class="dv">1</span></span>
<span id="cb3-14"><a href="#cb3-14"></a>    <span class="cf">if</span> sums <span class="kw">not</span> <span class="kw">in</span> dic:</span>
<span id="cb3-15"><a href="#cb3-15"></a>        dic[sums] <span class="op">=</span> i</span>
<span id="cb3-16"><a href="#cb3-16"></a>    <span class="cf">else</span>:</span>
<span id="cb3-17"><a href="#cb3-17"></a>        ans <span class="op">=</span> <span class="bu">max</span>(ans,i<span class="op">-</span>dic[sums])</span>
<span id="cb3-18"><a href="#cb3-18"></a><span class="bu">print</span>(ans)</span></code></pre></div>
</div>
<div id="最长子序列问题2" class="section level2" number="0.4">
<h2><span class="header-section-number">0.4</span> 最长子序列问题2</h2>
<p>题目描述
给定一个无序数组arr, 其中元素可正、可负、可0。给定一个整数k，求arr所有子数组中累加和为k的最长子数组长度
输入描述:
第一行两个整数N, k。N表示数组长度，k的定义已在题目描述中给出
第二行N个整数表示数组内的数</p>
<p>说白了就是考察前缀和的</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1"></a><span class="cf">while</span> <span class="va">True</span>:</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="cf">try</span>:</span>
<span id="cb4-3"><a href="#cb4-3"></a>        n, k <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>,<span class="bu">input</span>().split())</span>
<span id="cb4-4"><a href="#cb4-4"></a>        inputs <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>,<span class="bu">input</span>().split()))</span>
<span id="cb4-5"><a href="#cb4-5"></a>        sums <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-6"><a href="#cb4-6"></a>        res <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb4-7"><a href="#cb4-7"></a>        <span class="bu">dict</span> <span class="op">=</span> {<span class="dv">0</span>:<span class="op">-</span><span class="dv">1</span>}</span>
<span id="cb4-8"><a href="#cb4-8"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb4-9"><a href="#cb4-9"></a>            sums<span class="op">+=</span>inputs[i] </span>
<span id="cb4-10"><a href="#cb4-10"></a>            <span class="cf">if</span> sums <span class="kw">not</span> <span class="kw">in</span>  <span class="bu">dict</span>:</span>
<span id="cb4-11"><a href="#cb4-11"></a>                <span class="bu">dict</span>[sums]<span class="op">=</span>i</span>
<span id="cb4-12"><a href="#cb4-12"></a>            <span class="cf">if</span> sums<span class="op">-</span>k <span class="kw">in</span> <span class="bu">dict</span>:</span>
<span id="cb4-13"><a href="#cb4-13"></a>                res<span class="op">=</span><span class="bu">max</span>(res,i<span class="op">-</span><span class="bu">dict</span>[sums<span class="op">-</span>k]) <span class="co">#查看下子数组 的和</span></span>
<span id="cb4-14"><a href="#cb4-14"></a>        <span class="bu">print</span>(res)</span>
<span id="cb4-15"><a href="#cb4-15"></a>    <span class="cf">except</span>:<span class="cf">break</span></span></code></pre></div>
<p>’’’
# 前缀和的思想：对于数组arr[i],
建立和数组arrS[i]表示从序号0到i的值的和。
则对于数组arr[i]，
序号i+1到j的子数组和可以表示为arrS[j]-arrS[i]，
题目转化为求arrS[j]-k=arrS[i]是否存在。</p>
<p>没有想出更好的方法，只能借鉴一下大神的方法，在这里稍微说一下主要思路：
1.考虑到有正负数存在的情况，要考虑和为0的情况，
2.在遍历数组的循环外声明一个unordered_map，也就是哈希表，用来表示和为sum的最小数组长度
3.遍历数组时，对sum-k对应的哈希值进行查找，如果找到了，说明对应的下标内的前N个值的和+k=当前的sum值，反过来就可以求出当前找到的和为k的数组长度，再与之前的max比较即可求解
以上为个人拙见，希望可以帮助到大家</p>
<p>’’’</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>m存储前i项和对应下标，a存储前i项和，ans最大长，即求第i项时m[a<span class="op">-</span>k]是否存在</span>
<span id="cb5-2"><a href="#cb5-2"></a>def <span class="kw">solve</span>(l, n, k)<span class="op">:</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="st">    </span>m =<span class="st"> </span>{<span class="dv">0</span><span class="op">:-</span><span class="dv">1</span>}</span>
<span id="cb5-4"><a href="#cb5-4"></a>    a =<span class="st"> </span>ans =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb5-5"><a href="#cb5-5"></a>    <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(n)<span class="op">:</span></span>
<span id="cb5-6"><a href="#cb5-6"></a><span class="st">        </span>a <span class="op">+</span><span class="er">=</span><span class="st"> </span>l[i]</span>
<span id="cb5-7"><a href="#cb5-7"></a>        <span class="cf">if</span> a not <span class="cf">in</span> <span class="kw">m.keys</span>()<span class="op">:</span></span>
<span id="cb5-8"><a href="#cb5-8"></a><span class="st">            </span>m[a] =<span class="st"> </span>i</span>
<span id="cb5-9"><a href="#cb5-9"></a>        <span class="cf">if</span> a <span class="op">-</span><span class="st"> </span>k <span class="cf">in</span> <span class="kw">m.keys</span>()<span class="op">:</span></span>
<span id="cb5-10"><a href="#cb5-10"></a><span class="st">            </span>ans =<span class="st"> </span><span class="kw">max</span>(ans, i <span class="op">-</span><span class="st"> </span>m[a<span class="op">-</span>k])</span>
<span id="cb5-11"><a href="#cb5-11"></a>    return ans</span>
<span id="cb5-12"><a href="#cb5-12"></a></span>
<span id="cb5-13"><a href="#cb5-13"></a><span class="cf">while</span> True<span class="op">:</span></span>
<span id="cb5-14"><a href="#cb5-14"></a><span class="st">    </span>try<span class="op">:</span></span>
<span id="cb5-15"><a href="#cb5-15"></a><span class="st">        </span>n, k =<span class="st"> </span><span class="kw">map</span>(int, <span class="kw">input</span>()<span class="kw">.split</span>())</span>
<span id="cb5-16"><a href="#cb5-16"></a>        l =<span class="st"> </span><span class="kw">list</span>(<span class="kw">map</span>(int, <span class="kw">input</span>()<span class="kw">.split</span>()))</span>
<span id="cb5-17"><a href="#cb5-17"></a>        <span class="kw">print</span>(<span class="kw">solve</span>(l, n, k))</span>
<span id="cb5-18"><a href="#cb5-18"></a>    except EOFError<span class="op">:</span></span>
<span id="cb5-19"><a href="#cb5-19"></a><span class="st">        </span><span class="cf">break</span></span>
<span id="cb5-20"><a href="#cb5-20"></a></span></code></pre></div>
</div>
<div id="最长子序列问题3" class="section level2" number="0.5">
<h2><span class="header-section-number">0.5</span> 最长子序列问题3</h2>
<p>题目描述
给定一个无序数组arr，其中元素只能是1或0。求arr所有的子数组中0和1个数相等的最长子数组的长度
[要求]
时间复杂度为O(n)，空间复杂度为O(n)
输入描述:
第一行一个整数N，表示数组长度
接下来一行有N个数表示数组中的数</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a></span>
<span id="cb6-2"><a href="#cb6-2"></a>N =<span class="st"> </span><span class="kw">int</span>(<span class="kw">input</span>())</span>
<span id="cb6-3"><a href="#cb6-3"></a>nums =<span class="st"> </span><span class="kw">list</span>(<span class="kw">map</span>(int,<span class="kw">input</span>()<span class="kw">.split</span>()))</span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a>sums =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb6-6"><a href="#cb6-6"></a>dic =<span class="st"> </span>{<span class="dv">0</span><span class="op">:-</span><span class="dv">1</span>}</span>
<span id="cb6-7"><a href="#cb6-7"></a>ans =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(N)<span class="op">:</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="st">    </span><span class="cf">if</span> nums[i]<span class="op">==</span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="st">        </span>sums <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb6-12"><a href="#cb6-12"></a>    <span class="cf">else</span><span class="op">:</span></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="st">        </span>sums <span class="op">-</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb6-14"><a href="#cb6-14"></a>    <span class="cf">if</span> sums not <span class="cf">in</span> dic<span class="op">:</span></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="st">        </span>dic[sums] =<span class="st"> </span>i</span>
<span id="cb6-16"><a href="#cb6-16"></a>    <span class="cf">else</span><span class="op">:</span></span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="st">        </span>ans =<span class="st"> </span><span class="kw">max</span>(ans,i<span class="op">-</span>dic[sums])</span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="kw">print</span>(ans)</span></code></pre></div>
</div>
<div id="最长子序列问题4" class="section level2" number="0.6">
<h2><span class="header-section-number">0.6</span> 最长子序列问题4</h2>
<p>题目描述
给定一个数组arr，该数组无序，但每个值均为正数，再给定一个正数k。求arr的所有子数组中所有元素相加和为k的最长子数组的长度
例如，arr = [1, 2, 1, 1, 1], k = 3
累加和为3的最长子数组为[1, 1, 1]，所以结果返回3
[要求]
时间复杂度为O(n)，空间复杂度为O(1)</p>
<p>输入描述:
第一行两个整数N, k。N表示数组长度，k的定义已在题目描述中给出
第二行N个整数表示数组内的数</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1"></a>N, k <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split())</span>
<span id="cb7-2"><a href="#cb7-2"></a>ls <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>, <span class="bu">input</span>().split()))</span>
<span id="cb7-3"><a href="#cb7-3"></a>index <span class="op">=</span> <span class="dv">0</span> <span class="co">#最大子数组开始的索引值，因为就是求最长上升子序列的值</span></span>
<span id="cb7-4"><a href="#cb7-4"></a>max_len <span class="op">=</span> <span class="dv">1</span> <span class="co">#初始化最大长度值为1</span></span>
<span id="cb7-5"><a href="#cb7-5"></a>curr_sum <span class="op">=</span> <span class="dv">0</span> <span class="co">#当前子数组的和</span></span>
<span id="cb7-6"><a href="#cb7-6"></a><span class="co">#遍历列表ls</span></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</span>
<span id="cb7-8"><a href="#cb7-8"></a>    curr_sum <span class="op">+=</span> ls[i]</span>
<span id="cb7-9"><a href="#cb7-9"></a>    <span class="cf">while</span> curr_sum <span class="op">&gt;</span> k:</span>
<span id="cb7-10"><a href="#cb7-10"></a>        curr_sum <span class="op">-=</span> ls[index]</span>
<span id="cb7-11"><a href="#cb7-11"></a>        index <span class="op">+=</span> <span class="dv">1</span> <span class="co">#当前子数组的和去掉头元素后，索引要更新</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>    <span class="cf">if</span> curr_sum <span class="op">==</span> k:</span>
<span id="cb7-13"><a href="#cb7-13"></a>        max_len <span class="op">=</span> <span class="bu">max</span>(max_len, i<span class="op">-</span>index<span class="op">+</span><span class="dv">1</span>) <span class="co">#比较当前子数组(和为k)的长度是否比最大长度要大</span></span>
<span id="cb7-14"><a href="#cb7-14"></a><span class="bu">print</span>(max_len)</span>
<span id="cb7-15"><a href="#cb7-15"></a><span class="co">#最长上升子序列</span></span></code></pre></div>
</div>
<div id="最长子序列5" class="section level2" number="0.7">
<h2><span class="header-section-number">0.7</span> 最长子序列5</h2>
<p><strong>题目描述</strong></p>
<p>给定一个无序数组arr，其中元素可正、可负、可0。给定一个整数k，求arr所有的子数组中累加和小于或等于k的最长子数组长度
例如：arr = [3, -2, -4, 0, 6], k = -2. 相加和小于等于-2的最长子数组为{3, -2, -4, 0}，所以结果返回4
[要求]
时间复杂度为O(n)，空间复杂度为O(n)</p>
<p>这个答案依然没有看的很懂</p>
<blockquote>
<p>1）help[n]从后往前扫描计算对应位置i的最小累加和；
2）ends[n]，用来记录当前位置所对应的累加和的结束位置；
首先，对数组arr[n]进行第一遍扫描，填满help[n]和ends[n]。
接着从左往右，根据arr[n]，ends[n]和arr[n]结算和寻找最长的子数组,原则很简单,相邻两端的和小于就继续,否则中断,进行长度比对,然后继续,直到end或i等于n。</p>
</blockquote>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">def</span> maxlens(n,k,arr):</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="bu">help</span><span class="op">=</span>[<span class="dv">0</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n)]    <span class="co"># 用来记录从右到左第一个大于0的累加和</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    <span class="bu">help</span>[<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> arr[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb8-4"><a href="#cb8-4"></a>    <span class="bu">dict</span> <span class="op">=</span>{}    <span class="co"># 记录累加和的位置,此题又是考察前缀和</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>    <span class="bu">dict</span>[n<span class="op">-</span><span class="dv">1</span>] <span class="op">=</span> n<span class="op">-</span><span class="dv">1</span></span>
<span id="cb8-6"><a href="#cb8-6"></a>    <span class="co"># 计算从右边到i的刚刚大于0的和and位置</span></span>
<span id="cb8-7"><a href="#cb8-7"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n<span class="op">-</span><span class="dv">2</span>,<span class="op">-</span><span class="dv">1</span>,<span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb8-8"><a href="#cb8-8"></a>        <span class="cf">if</span> <span class="bu">help</span>[i<span class="op">+</span><span class="dv">1</span>] <span class="op">&lt;=</span> <span class="dv">0</span>:</span>
<span id="cb8-9"><a href="#cb8-9"></a>            <span class="bu">help</span>[i] <span class="op">=</span> <span class="bu">help</span>[i<span class="op">+</span><span class="dv">1</span>] <span class="op">+</span> arr[i]</span>
<span id="cb8-10"><a href="#cb8-10"></a>            <span class="bu">dict</span>[i] <span class="op">=</span> <span class="bu">dict</span>[i<span class="op">+</span><span class="dv">1</span>]</span>
<span id="cb8-11"><a href="#cb8-11"></a>        <span class="cf">else</span>:</span>
<span id="cb8-12"><a href="#cb8-12"></a>            <span class="bu">help</span>[i] <span class="op">=</span> arr[i]</span>
<span id="cb8-13"><a href="#cb8-13"></a>            <span class="bu">dict</span>[i] <span class="op">=</span> i</span>
<span id="cb8-14"><a href="#cb8-14"></a>    <span class="co"># 从左到右计算累加和的数组长度</span></span>
<span id="cb8-15"><a href="#cb8-15"></a>    sums,end,maxlen <span class="op">=</span> <span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span><span class="co"># 子数组累加和，子数组右边的边界，数组最大长度</span></span>
<span id="cb8-16"><a href="#cb8-16"></a>    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb8-17"><a href="#cb8-17"></a>        <span class="cf">while</span> end <span class="op">&lt;</span> n <span class="kw">and</span> sums <span class="op">+</span> <span class="bu">help</span>[end] <span class="op">&lt;=</span> k:</span>
<span id="cb8-18"><a href="#cb8-18"></a>            sums <span class="op">+=</span> <span class="bu">help</span>[end]</span>
<span id="cb8-19"><a href="#cb8-19"></a>            end <span class="op">=</span> <span class="bu">dict</span>[end] <span class="op">+</span> <span class="dv">1</span></span>
<span id="cb8-20"><a href="#cb8-20"></a>        <span class="co"># 此时数组累加和是大于k的</span></span>
<span id="cb8-21"><a href="#cb8-21"></a>        maxlen <span class="op">=</span> <span class="bu">max</span>(maxlen,end<span class="op">-</span>i)</span>
<span id="cb8-22"><a href="#cb8-22"></a>        <span class="co"># 数组左边界向前移动</span></span>
<span id="cb8-23"><a href="#cb8-23"></a>        sums <span class="op">-=</span> arr[i]</span>
<span id="cb8-24"><a href="#cb8-24"></a>    <span class="cf">return</span> maxlen</span>
<span id="cb8-25"><a href="#cb8-25"></a></span>
<span id="cb8-26"><a href="#cb8-26"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb8-27"><a href="#cb8-27"></a>    n,k <span class="op">=</span> <span class="bu">map</span>(<span class="bu">int</span>,<span class="bu">input</span>().split())</span>
<span id="cb8-28"><a href="#cb8-28"></a>    arr <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>,<span class="bu">input</span>().split()))</span>
<span id="cb8-29"><a href="#cb8-29"></a>    <span class="bu">print</span>(maxlens(n,k,arr))</span></code></pre></div>
</div>
<div id="最长可整合子数组的长度" class="section level2" number="0.8">
<h2><span class="header-section-number">0.8</span> 最长可整合子数组的长度</h2>
<p>题目描述
先给出可整合数组的定义：如果一个数组在排序之后，每相邻两个数的差的绝对值都为1，或者该数组长度为1，则该数组为可整合数组。例如，[5, 3, 4, 6, 2]排序后为[2, 3, 4, 5, 6]，符合每相邻两个数差的绝对值都为1，所以这个数组为可整合数组
给定一个数组arr, 请返回其中最大可整合子数组的长度。例如，[5, 5, 3, 2, 6, 4, 3]的最大可整合子数组为[5, 3, 2, 6, 4]，所以请返回5
[要求]
时间复杂度为O(n^2)O(n
2
)，空间复杂度为O(n)O(n)
输入描述:
第一行一个整数N，表示数组长度
第二行N个整数，分别表示数组内的元素</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="cf">while</span> True<span class="op">:</span></span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="st">    </span>try<span class="op">:</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="st">        </span>n =<span class="st"> </span><span class="kw">int</span>(<span class="kw">input</span>())</span>
<span id="cb9-4"><a href="#cb9-4"></a>        l =<span class="st"> </span><span class="kw">list</span>(<span class="kw">map</span>(int, <span class="kw">input</span>()<span class="kw">.split</span>()))</span>
<span id="cb9-5"><a href="#cb9-5"></a>        l =<span class="st"> </span><span class="kw">sorted</span>(<span class="kw">list</span>(<span class="kw">set</span>(l)))</span>
<span id="cb9-6"><a href="#cb9-6"></a>        tmp =<span class="st"> </span>maxL =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb9-7"><a href="#cb9-7"></a>        n =<span class="st"> </span><span class="kw">len</span>(l)</span>
<span id="cb9-8"><a href="#cb9-8"></a>        <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>, n)<span class="op">:</span></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="st">            </span><span class="cf">if</span> l[i] <span class="op">-</span><span class="st"> </span>l[i<span class="dv">-1</span>] <span class="op">==</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="st">                </span>tmp <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb9-11"><a href="#cb9-11"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb9-12"><a href="#cb9-12"></a><span class="st">                </span>maxL =<span class="st"> </span><span class="kw">max</span>(maxL, tmp)</span>
<span id="cb9-13"><a href="#cb9-13"></a>                tmp =<span class="st"> </span><span class="dv">1</span> <span class="co">#就重新开始计算，我感觉整个思路还是很新的</span></span>
<span id="cb9-14"><a href="#cb9-14"></a>        <span class="kw">print</span>(<span class="kw">max</span>(maxL, tmp))</span>
<span id="cb9-15"><a href="#cb9-15"></a>    except EOFError<span class="op">:</span></span>
<span id="cb9-16"><a href="#cb9-16"></a><span class="st">        </span><span class="cf">break</span></span></code></pre></div>
</div>
<div id="背包问题" class="section level2" number="0.9">
<h2><span class="header-section-number">0.9</span> 背包问题</h2>
<p>背包问题是需要考虑价值的
- [ ] 找下原问题，理解一下</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a>MAX =<span class="st"> </span><span class="dv">1001</span></span>
<span id="cb10-2"><a href="#cb10-2"></a>def <span class="kw">solve</span>(l, n, k)<span class="op">:</span></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="st">    </span>c =<span class="st"> </span>[MAX]<span class="op">*</span>(k<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb10-4"><a href="#cb10-4"></a>    c[<span class="dv">0</span>] =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb10-5"><a href="#cb10-5"></a>    <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(n)<span class="op">:</span></span>
<span id="cb10-6"><a href="#cb10-6"></a><span class="st">        </span><span class="cf">for</span> v <span class="cf">in</span> <span class="kw">range</span>(l[i], k<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb10-7"><a href="#cb10-7"></a><span class="st">            </span>c[v] =<span class="st"> </span><span class="kw">min</span>(c[v], c[v<span class="op">-</span>l[i]]<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb10-8"><a href="#cb10-8"></a>    return c[k] <span class="cf">if</span> c[k] <span class="op">!=</span><span class="st"> </span>MAX <span class="cf">else</span> <span class="dv">-1</span></span>
<span id="cb10-9"><a href="#cb10-9"></a></span>
<span id="cb10-10"><a href="#cb10-10"></a><span class="cf">while</span> True<span class="op">:</span></span>
<span id="cb10-11"><a href="#cb10-11"></a><span class="st">    </span>try<span class="op">:</span></span>
<span id="cb10-12"><a href="#cb10-12"></a><span class="st">        </span>n, k =<span class="st"> </span><span class="kw">map</span>(int, <span class="kw">input</span>()<span class="kw">.split</span>())</span>
<span id="cb10-13"><a href="#cb10-13"></a>        l =<span class="st"> </span><span class="kw">list</span>(<span class="kw">map</span>(int, <span class="kw">input</span>()<span class="kw">.split</span>()))</span>
<span id="cb10-14"><a href="#cb10-14"></a>        <span class="kw">print</span>(<span class="kw">solve</span>(l, n, k))</span>
<span id="cb10-15"><a href="#cb10-15"></a>    except EOFError<span class="op">:</span></span>
<span id="cb10-16"><a href="#cb10-16"></a><span class="st">        </span><span class="cf">break</span></span></code></pre></div>
</div>
<div id="零钱兑换问题" class="section level2" number="0.10">
<h2><span class="header-section-number">0.10</span> 零钱兑换问题</h2>
<p>题目描述
给定数组arr，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个aim，代表要找的钱数，求组成aim的最少货币数。
输入描述:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1"></a>def <span class="kw">change_cion</span>(arr,aim)<span class="op">:</span></span>
<span id="cb11-2"><a href="#cb11-2"></a><span class="st">    </span>dp =<span class="st"> </span>[<span class="dv">0</span>]<span class="op">+</span>[<span class="kw">float</span>(<span class="st">&#39;inf&#39;</span>)]<span class="op">*</span>aim</span>
<span id="cb11-3"><a href="#cb11-3"></a>    <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(<span class="dv">1</span>,aim<span class="op">+</span><span class="dv">1</span>)<span class="op">:</span></span>
<span id="cb11-4"><a href="#cb11-4"></a><span class="st">        </span><span class="cf">for</span> j <span class="cf">in</span> arr<span class="op">:</span></span>
<span id="cb11-5"><a href="#cb11-5"></a><span class="st">            </span><span class="cf">if</span> j <span class="op">&lt;=</span><span class="st"> </span>i and dp[i<span class="op">-</span>j]<span class="op">+</span><span class="dv">1</span><span class="op">&lt;</span>dp[i]<span class="op">:</span></span>
<span id="cb11-6"><a href="#cb11-6"></a><span class="st">                </span>dp[i] =<span class="st"> </span>dp[i<span class="op">-</span>j]<span class="op">+</span><span class="dv">1</span></span>
<span id="cb11-7"><a href="#cb11-7"></a>    <span class="cf">if</span> dp[aim] <span class="op">==</span><span class="st"> </span><span class="kw">float</span>(<span class="st">&#39;inf&#39;</span>)<span class="op">:</span></span>
<span id="cb11-8"><a href="#cb11-8"></a><span class="st">        </span>return <span class="dv">-1</span></span>
<span id="cb11-9"><a href="#cb11-9"></a>    <span class="cf">else</span><span class="op">:</span></span>
<span id="cb11-10"><a href="#cb11-10"></a><span class="st">        </span>return dp[aim]</span>
<span id="cb11-11"><a href="#cb11-11"></a>n,aim =<span class="st"> </span><span class="kw">map</span>(int,<span class="kw">input</span>()<span class="kw">.split</span>())</span>
<span id="cb11-12"><a href="#cb11-12"></a>arr =<span class="st"> </span><span class="kw">list</span>(<span class="kw">map</span>(int,<span class="kw">input</span>()<span class="kw">.split</span>()))</span>
<span id="cb11-13"><a href="#cb11-13"></a><span class="kw">print</span>(<span class="kw">change_cion</span>(arr,aim))</span></code></pre></div>
</div>
<div id="求最大子矩阵的大小" class="section level2" number="0.11">
<h2><span class="header-section-number">0.11</span> 求最大子矩阵的大小</h2>
<p>题目描述
给定一个整型矩阵 map，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域里 1 的数量。</p>
<p>输入描述:
第一行输入两个整数 n 和 m，代表 n<em>m 的矩阵
接下来输入一个 n</em>m 的矩阵</p>
<p>例子：
1 0 1 0
0 1 1 0
0 1 1 0
0 1 0 1</p>
<p>最大子矩阵的大小为2*2</p>
<!-- 貌似也是转化为了直方图求面积 -->
<blockquote>
<p>思路非常好懂，遍历每一行，以当前行为底，统计在此行之上连续的1的个数，像直方图一样；此时，问题重新转化为单调栈问题，时间和空间复杂度为O(M)。再考虑有N行，则总的时间复杂度为O(N*M)</p>
</blockquote>
<p><del>- [ ] 还没看懂啊</del></p>
<p>突然明白了，这个题类似与求最高的水位面积的那个，这是转化直方图之后的思想</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>def <span class="kw">f</span>()<span class="op">:</span></span>
<span id="cb12-2"><a href="#cb12-2"></a><span class="st">    </span>n,m=<span class="kw">map</span>(int,<span class="kw">input</span>()<span class="kw">.split</span>())</span>
<span id="cb12-3"><a href="#cb12-3"></a>    M=[]</span>
<span id="cb12-4"><a href="#cb12-4"></a>    <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(n)<span class="op">:</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="st">        </span><span class="kw">M.append</span>(<span class="kw">list</span>(<span class="kw">map</span>(int,<span class="kw">input</span>()<span class="kw">.split</span>())))</span>
<span id="cb12-6"><a href="#cb12-6"></a>    tmp =[<span class="dv">0</span>]<span class="op">*</span>(m<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb12-7"><a href="#cb12-7"></a>    res=<span class="dv">0</span></span>
<span id="cb12-8"><a href="#cb12-8"></a>    <span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(n)<span class="op">:</span></span>
<span id="cb12-9"><a href="#cb12-9"></a><span class="st">        </span><span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(m)<span class="op">:</span></span>
<span id="cb12-10"><a href="#cb12-10"></a><span class="st">            </span><span class="cf">if</span> M[i][j]<span class="op">:</span></span>
<span id="cb12-11"><a href="#cb12-11"></a><span class="st">                </span>tmp[j] <span class="op">+</span><span class="er">=</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb12-12"><a href="#cb12-12"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb12-13"><a href="#cb12-13"></a><span class="st">                </span>tmp[j] =<span class="st"> </span><span class="dv">0</span></span>
<span id="cb12-14"><a href="#cb12-14"></a>        stack =<span class="st"> </span>[]</span>
<span id="cb12-15"><a href="#cb12-15"></a>        <span class="cf">for</span> k <span class="cf">in</span> <span class="kw">range</span>(<span class="kw">len</span>(tmp))<span class="op">:</span></span>
<span id="cb12-16"><a href="#cb12-16"></a><span class="st">            </span><span class="cf">while</span> stack and tmp[k]<span class="op">&lt;</span>tmp[stack[<span class="op">-</span><span class="dv">1</span>]]<span class="op">:</span></span>
<span id="cb12-17"><a href="#cb12-17"></a><span class="st">                </span>height =<span class="st"> </span>tmp[<span class="kw">stack.pop</span>()]</span>
<span id="cb12-18"><a href="#cb12-18"></a>                start =<span class="op">-</span><span class="dv">1</span></span>
<span id="cb12-19"><a href="#cb12-19"></a>                <span class="cf">if</span> stack <span class="op">:</span></span>
<span id="cb12-20"><a href="#cb12-20"></a><span class="st">                    </span>start =<span class="st"> </span>stack[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb12-21"><a href="#cb12-21"></a>                res =<span class="st"> </span><span class="kw">max</span>(res,(k<span class="op">-</span>start<span class="dv">-1</span>)<span class="op">*</span>height)</span>
<span id="cb12-22"><a href="#cb12-22"></a>            <span class="kw">stack.append</span>(k)</span>
<span id="cb12-23"><a href="#cb12-23"></a>    <span class="kw">print</span>(res)           </span>
<span id="cb12-24"><a href="#cb12-24"></a><span class="kw">f</span>()</span></code></pre></div>
</div>
<div id="换钱的方法" class="section level2" number="0.12">
<h2><span class="header-section-number">0.12</span> 换钱的方法</h2>
<p>题目描述
给定数组arr，设数组长度为n，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim，代表要找的钱数，求换钱的方法数有多少种。由于方法的种数比较大，所以要求输出对10^9+710
9
+7进行取模后的答案。
输入描述:
输出包括两行，第一行包括两个整数n(0 n )(0≤n≤1000)和aim(0 aim )(0≤aim≤20000)。第二行包含n个整数，表示arr数组( 1 arr_i 1e9 )(1≤arr
i≤1e9)。</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1"></a>n,aim <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>,<span class="bu">input</span>().split()))</span>
<span id="cb13-2"><a href="#cb13-2"></a>arr <span class="op">=</span> <span class="bu">list</span>(<span class="bu">map</span>(<span class="bu">int</span>,<span class="bu">input</span>().split()))</span>
<span id="cb13-3"><a href="#cb13-3"></a><span class="co">#arr.sort(reverse=True)</span></span>
<span id="cb13-4"><a href="#cb13-4"></a><span class="kw">def</span> shaibi(arr,aim):</span>
<span id="cb13-5"><a href="#cb13-5"></a>    res <span class="op">=</span> [<span class="dv">1</span>]<span class="op">+</span>[<span class="dv">0</span>]<span class="op">*</span>aim <span class="co"># 第0位是辅助位，代表面额数刚好等于金钱数的一种情况</span></span>
<span id="cb13-6"><a href="#cb13-6"></a>    <span class="cf">for</span> x <span class="kw">in</span> arr:</span>
<span id="cb13-7"><a href="#cb13-7"></a>        <span class="cf">for</span> j <span class="kw">in</span> <span class="bu">range</span>(x,aim<span class="op">+</span><span class="dv">1</span>):</span>
<span id="cb13-8"><a href="#cb13-8"></a>            res[j] <span class="op">+=</span> res[j<span class="op">-</span>x]</span>
<span id="cb13-9"><a href="#cb13-9"></a>    <span class="cf">return</span> res[<span class="op">-</span><span class="dv">1</span>]<span class="op">%</span><span class="dv">1000000007</span></span>
<span id="cb13-10"><a href="#cb13-10"></a>a <span class="op">=</span> shaibi(arr,aim)</span>
<span id="cb13-11"><a href="#cb13-11"></a><span class="bu">print</span>(a)</span>
<span id="cb13-12"><a href="#cb13-12"></a><span class="co">&#39;&#39;&#39;</span></span>
<span id="cb13-13"><a href="#cb13-13"></a><span class="co">解题思路：</span></span>
<span id="cb13-14"><a href="#cb13-14"></a><span class="co">动态规划核心状态转移方程式</span></span>
<span id="cb13-15"><a href="#cb13-15"></a><span class="co">f（n） = f(n - arr[0]) + f(n - arr[1]) + f(n - arr[2]) + ... + f(n - arr[i]) i为arr的长度</span></span>
<span id="cb13-16"><a href="#cb13-16"></a><span class="co">对于组成n的情况，每个arr[i]元与f（n - arr[i]）都可以组成一个n，所以把每种f（n - arr[i]）的种类数</span></span>
<span id="cb13-17"><a href="#cb13-17"></a><span class="co">相加，就找出了arr能组成n的种类。递归计算会重复计算f（n - arr[i]），运用斐波那契数列类似的方法，</span></span>
<span id="cb13-18"><a href="#cb13-18"></a><span class="co">从0开始遍历，重复利用计算过的f（n - arr[i]）。结果数值会过大，题目要求输出对10 ^ 9 +7取模后的答案。</span></span>
<span id="cb13-19"><a href="#cb13-19"></a><span class="co">&#39;&#39;&#39;</span></span></code></pre></div>
</div>
<div id="二分法查找" class="section level2" number="0.13">
<h2><span class="header-section-number">0.13</span> 二分法查找</h2>
<p>二分法查找/折半查找的时间复杂度是nlog(n)</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="co">#递归实现二分查找 li是列表   item是要查找的元素</span></span>
<span id="cb14-2"><a href="#cb14-2"></a>def <span class="kw">merge_search</span>( li ,item )<span class="op">:</span></span>
<span id="cb14-3"><a href="#cb14-3"></a><span class="st">    </span><span class="co">#传来的列表每次都是新生成的，如果发现里面没有元素，则是查找到尽头都没找到</span></span>
<span id="cb14-4"><a href="#cb14-4"></a><span class="st">    </span><span class="cf">if</span> not li <span class="op">:</span></span>
<span id="cb14-5"><a href="#cb14-5"></a><span class="st">        </span>return False</span>
<span id="cb14-6"><a href="#cb14-6"></a></span>
<span id="cb14-7"><a href="#cb14-7"></a>    mid =<span class="st"> </span><span class="kw">len</span>(li)<span class="op">/</span><span class="er">/</span><span class="dv">2</span>   <span class="co">#mid记录li的中间位置</span></span>
<span id="cb14-8"><a href="#cb14-8"></a>    <span class="co">#检查一下 如果中间这个数就是要找的元素 返回真</span></span>
<span id="cb14-9"><a href="#cb14-9"></a>    <span class="cf">if</span> li[mid] <span class="op">==</span><span class="st"> </span>item <span class="op">:</span></span>
<span id="cb14-10"><a href="#cb14-10"></a><span class="st">        </span>return True</span>
<span id="cb14-11"><a href="#cb14-11"></a>    <span class="co"># 如果mid比item大，说明item可能会出现在mid左边，对左边再查找</span></span>
<span id="cb14-12"><a href="#cb14-12"></a>    elif li[mid]<span class="op">&gt;</span><span class="st"> </span>item <span class="op">:</span></span>
<span id="cb14-13"><a href="#cb14-13"></a><span class="st">        </span>return <span class="kw">merge_search</span>( li[<span class="op">:</span>mid] ,item )</span>
<span id="cb14-14"><a href="#cb14-14"></a>    <span class="co"># mid 比item小，说明item有可能在mid右边，对右边再查找</span></span>
<span id="cb14-15"><a href="#cb14-15"></a>    <span class="cf">else</span> <span class="op">:</span></span>
<span id="cb14-16"><a href="#cb14-16"></a><span class="st">        </span>return <span class="kw">merge_search</span>( li[mid<span class="op">+</span><span class="dv">1</span><span class="op">:</span>] , item )</span>
<span id="cb14-17"><a href="#cb14-17"></a></span>
<span id="cb14-18"><a href="#cb14-18"></a><span class="cf">if</span> __name__ <span class="op">==</span><span class="st"> &#39;__main__&#39;</span><span class="op">:</span></span>
<span id="cb14-19"><a href="#cb14-19"></a><span class="st">    </span>li =<span class="st"> </span>[<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">5</span>,<span class="dv">6</span>,<span class="dv">7</span>]</span>
<span id="cb14-20"><a href="#cb14-20"></a>    <span class="kw">print</span>( <span class="kw">merge_search</span>(li , <span class="dv">0</span>) )   <span class="co">#False</span></span>
<span id="cb14-21"><a href="#cb14-21"></a>    <span class="kw">print</span>( <span class="kw">merge_search</span>(li , <span class="dv">1</span>) )   <span class="co">#True</span></span></code></pre></div>
<p>因此需要看一个二分法查找的例子</p>
<p><strong>题目描述</strong></p>
<p>请实现有重复数字的有序数组的二分查找。
输出在数组中第一个大于等于查找值的位置，如果数组中不存在这样的数，则输出数组长度加一。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1"></a><span class="co"># 二分查找</span></span>
<span id="cb15-2"><a href="#cb15-2"></a><span class="co"># @param n int整型 数组长度</span></span>
<span id="cb15-3"><a href="#cb15-3"></a><span class="co"># @param v int整型 查找值</span></span>
<span id="cb15-4"><a href="#cb15-4"></a><span class="co"># @param a int整型一维数组 有序数组</span></span>
<span id="cb15-5"><a href="#cb15-5"></a><span class="co"># @return int整型</span></span>
<span id="cb15-6"><a href="#cb15-6"></a>class Solution<span class="op">:</span></span>
<span id="cb15-7"><a href="#cb15-7"></a><span class="st">    </span>def <span class="kw">__init__</span>(self)<span class="op">:</span></span>
<span id="cb15-8"><a href="#cb15-8"></a><span class="st">        </span>data =<span class="st"> </span><span class="kw">input</span>()<span class="kw">.split</span>(<span class="st">&quot;,&quot;</span>, <span class="dv">2</span>)</span>
<span id="cb15-9"><a href="#cb15-9"></a>        self.n =<span class="st"> </span><span class="kw">int</span>(data[<span class="dv">0</span>])</span>
<span id="cb15-10"><a href="#cb15-10"></a>        self.v =<span class="st"> </span><span class="kw">int</span>(data[<span class="dv">1</span>])</span>
<span id="cb15-11"><a href="#cb15-11"></a>        self.a =<span class="st"> </span><span class="kw">eval</span>(data[<span class="dv">2</span>]) <span class="co">#这里其实也可以不这么写啊，输入的话</span></span>
<span id="cb15-12"><a href="#cb15-12"></a>    def <span class="kw">upper_bound_</span>(self)<span class="op">:</span></span>
<span id="cb15-13"><a href="#cb15-13"></a><span class="st">        </span><span class="co"># write code here</span></span>
<span id="cb15-14"><a href="#cb15-14"></a><span class="st">        </span><span class="cf">if</span> self.v <span class="op">&gt;</span><span class="st"> </span>self.a[<span class="op">-</span><span class="dv">1</span>]<span class="op">:</span></span>
<span id="cb15-15"><a href="#cb15-15"></a><span class="st">            </span>return self.n<span class="op">+</span><span class="dv">1</span></span>
<span id="cb15-16"><a href="#cb15-16"></a>        l, r =<span class="st"> </span><span class="dv">0</span>, self.n<span class="dv">-1</span></span>
<span id="cb15-17"><a href="#cb15-17"></a>        <span class="cf">while</span> l<span class="op">&lt;=</span>r<span class="op">:</span></span>
<span id="cb15-18"><a href="#cb15-18"></a><span class="st">            </span>m =<span class="st"> </span>(l<span class="op">+</span>r)<span class="op">/</span><span class="er">/</span><span class="dv">2</span> <span class="co"># 整体的思想就是折半查找</span></span>
<span id="cb15-19"><a href="#cb15-19"></a>            <span class="cf">if</span> self.a[m]<span class="op">&lt;=</span>(self.v<span class="dv">-1</span>)<span class="op">:</span></span>
<span id="cb15-20"><a href="#cb15-20"></a><span class="st">                </span>l =<span class="st"> </span>m <span class="op">+</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb15-21"><a href="#cb15-21"></a>            <span class="cf">else</span><span class="op">:</span></span>
<span id="cb15-22"><a href="#cb15-22"></a><span class="st">                </span>r =<span class="st"> </span>m <span class="op">-</span><span class="st"> </span><span class="dv">1</span></span>
<span id="cb15-23"><a href="#cb15-23"></a>        right =<span class="st"> </span>l</span>
<span id="cb15-24"><a href="#cb15-24"></a>        return right<span class="op">+</span><span class="dv">1</span></span>
<span id="cb15-25"><a href="#cb15-25"></a>solution =<span class="st"> </span><span class="kw">Solution</span>()</span>
<span id="cb15-26"><a href="#cb15-26"></a>res =<span class="st"> </span><span class="kw">solution.upper_bound_</span>()</span>
<span id="cb15-27"><a href="#cb15-27"></a><span class="kw">print</span>(res)</span></code></pre></div>
</div>
<div id="二叉树的先序中序后序遍历" class="section level2" number="0.14">
<h2><span class="header-section-number">0.14</span> 二叉树的先序中序后序遍历</h2>
<p>输入
{1,2,3}
输出
[[1,2,3],[2,1,3],[2,3,1]]</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a>class TreeNode<span class="op">:</span></span>
<span id="cb16-2"><a href="#cb16-2"></a><span class="st">    </span>def <span class="kw">__init__</span>(self, x)<span class="op">:</span></span>
<span id="cb16-3"><a href="#cb16-3"></a><span class="st">         </span>self.val =<span class="st"> </span>x</span>
<span id="cb16-4"><a href="#cb16-4"></a>         self.left =<span class="st"> </span>None</span>
<span id="cb16-5"><a href="#cb16-5"></a>         self.right =<span class="st"> </span>None</span>
<span id="cb16-6"><a href="#cb16-6"></a><span class="co">#</span></span>
<span id="cb16-7"><a href="#cb16-7"></a><span class="co"># @param root TreeNode类 the root of binary tree</span></span>
<span id="cb16-8"><a href="#cb16-8"></a><span class="co"># @return int整型二维数组</span></span>
<span id="cb16-9"><a href="#cb16-9"></a><span class="co">#</span></span>
<span id="cb16-10"><a href="#cb16-10"></a>class Solution<span class="op">:</span></span>
<span id="cb16-11"><a href="#cb16-11"></a><span class="st">    </span>def <span class="kw">threeOrders</span>(self , root )<span class="op">:</span></span>
<span id="cb16-12"><a href="#cb16-12"></a><span class="st">        </span>pre_order, in_order, post_order =<span class="st"> </span>[], [], []</span>
<span id="cb16-13"><a href="#cb16-13"></a>        def <span class="kw">find</span>(root)<span class="op">:</span></span>
<span id="cb16-14"><a href="#cb16-14"></a><span class="st">            </span><span class="cf">if</span> not root<span class="op">:</span><span class="st"> </span>return None</span>
<span id="cb16-15"><a href="#cb16-15"></a>            <span class="kw">pre_order.append</span>(root.val)  <span class="co"># 先序：根左右</span></span>
<span id="cb16-16"><a href="#cb16-16"></a>            <span class="kw">find</span>(root.left)  <span class="co"># 这个是递归吧</span></span>
<span id="cb16-17"><a href="#cb16-17"></a>            <span class="kw">in_order.append</span>(root.val)   <span class="co"># 中序：左根右</span></span>
<span id="cb16-18"><a href="#cb16-18"></a>            <span class="kw">find</span>(root.right)</span>
<span id="cb16-19"><a href="#cb16-19"></a>            <span class="kw">post_order.append</span>(root.val) <span class="co"># 后序：左右根</span></span>
<span id="cb16-20"><a href="#cb16-20"></a>        <span class="kw">find</span>(root)</span>
<span id="cb16-21"><a href="#cb16-21"></a>        return [pre_order, in_order, post_order]</span>
<span id="cb16-22"><a href="#cb16-22"></a>    </span></code></pre></div>
</div>
<div id="机器人到达指定位置的方法数" class="section level2" number="0.15">
<h2><span class="header-section-number">0.15</span> 机器人到达指定位置的方法数</h2>
<p><strong>题目描述</strong></p>
<p>假设有排成一行的N个位置，记为1~N，开始时机器人在M位置，机器人可以往左或者往右走，如果机器人在1位置，那么下一步机器人只能走到2位置，如果机器人在N位置，那么下一步机器人只能走到N-1位置。规定机器人只能走k步，最终能来到P位置的方法有多少种。由于方案数可能比较大，所以答案需要对1e9+7取模。</p>
<p>输入描述:
输出包括一行四个正整数N（2&lt;=N&lt;=5000）、M(1&lt;=M&lt;=N)、K(1&lt;=K&lt;=5000)、P(1&lt;=P&lt;=N)。
输出描述:
输出一个整数，代表最终走到P的方法数对10^9+7109+7取模后的值。</p>
<p>画个图可能更加直观</p>
<p>机器人路径规划可以处一个板块了</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>n,m,k,p =<span class="st"> </span><span class="kw">map</span>(int,<span class="kw">input</span>()<span class="kw">.split</span>())</span>
<span id="cb17-2"><a href="#cb17-2"></a>dp =<span class="st"> </span>[<span class="dv">0</span>] <span class="op">*</span><span class="st"> </span>(n<span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb17-3"><a href="#cb17-3"></a>dp[p<span class="dv">-1</span>] =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a><span class="cf">for</span> i <span class="cf">in</span> <span class="kw">range</span>(k)<span class="op">:</span></span>
<span id="cb17-6"><a href="#cb17-6"></a><span class="st">    </span>leftup =<span class="st"> </span>dp[<span class="dv">0</span>]</span>
<span id="cb17-7"><a href="#cb17-7"></a>    <span class="cf">for</span> j <span class="cf">in</span> <span class="kw">range</span>(n)<span class="op">:</span></span>
<span id="cb17-8"><a href="#cb17-8"></a><span class="st">        </span>temp =<span class="st"> </span>dp[j]</span>
<span id="cb17-9"><a href="#cb17-9"></a>        <span class="cf">if</span> j <span class="op">==</span><span class="st"> </span><span class="dv">0</span><span class="op">:</span></span>
<span id="cb17-10"><a href="#cb17-10"></a><span class="st">            </span>dp[j] =<span class="st"> </span>dp[j<span class="op">+</span><span class="dv">1</span>]%<span class="dv">100000007</span></span>
<span id="cb17-11"><a href="#cb17-11"></a>        elif j <span class="op">==</span><span class="st"> </span>n<span class="dv">-1</span><span class="op">:</span></span>
<span id="cb17-12"><a href="#cb17-12"></a><span class="st">            </span>dp[j] =<span class="st"> </span>leftup%<span class="dv">100000007</span></span>
<span id="cb17-13"><a href="#cb17-13"></a>        <span class="cf">else</span><span class="op">:</span></span>
<span id="cb17-14"><a href="#cb17-14"></a><span class="st">            </span>dp[j] =<span class="st"> </span>(leftup <span class="op">+</span><span class="st"> </span>dp[j<span class="op">+</span><span class="dv">1</span>])%<span class="dv">100000007</span></span>
<span id="cb17-15"><a href="#cb17-15"></a>        leftup =<span class="st"> </span>temp</span>
<span id="cb17-16"><a href="#cb17-16"></a><span class="kw">print</span>(dp[m<span class="dv">-1</span>])</span>
<span id="cb17-17"><a href="#cb17-17"></a></span>
<span id="cb17-18"><a href="#cb17-18"></a></span>
<span id="cb17-19"><a href="#cb17-19"></a><span class="co"># 动态规划的思想</span></span></code></pre></div>
</div>
<div id="打气球的最大分数" class="section level2" number="0.16">
<h2><span class="header-section-number">0.16</span> 打气球的最大分数</h2>
<p>题目描述
给定一个数组arr,长度为n。代表排有分数的气球。 每打爆一个气球都能获得分数，假设打爆气球的分数为X，获得分数的规则如下:
1)如果被打爆气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为L:如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为R.获得分数为L<em>X</em>R
2)如果被打爆的气球的左边有没被打爆的气球，找到离被打爆气球最近的气球，假设分数为L:如果被打爆气球的右边所有气球都已经被打爆，获得分数为L<em>X。
3)如果被打爆气球的左边所有的气球都已经被打爆:如果被打爆气球的右边有没被打爆的气球，找到离被打爆气球最近的气球。获得分数为X</em>R.
4)如果被打爆气球的左边和右边所有的气球都已经被打爆。获得分数为X。
目标是打爆所有气球，获得每次打爆的分数。通过选择打爆气球的顺序，可以得到不同的总分，请返回能获得的最大分数。
输入描述:
输出包括两行，第一行包括一个整数n（0&lt;=n&lt;=500），第二行包括n个整数，代表数组arr （1&lt;=arr[i]&lt;=100）。
输出描述:
输出包括一个整数，代表可能获得的最大分数。
示例1
输入
复制
3
3 2 5
输出
复制
50
说明
2-&gt;1-&gt;3 3<em>2</em>5+3*5+5=50
示例2
输入
复制
8
23 4 45 65 23 43 54 56
输出
复制
639019</p>
</div>
<div id="维特比算法" class="section level2" number="0.17">
<h2><span class="header-section-number">0.17</span> 维特比算法</h2>
<p>目前可以简单的理解为动态规划，因此需要用动态规划的方式进行解题</p>
</div>
            </section>

          </div>
        </div>
      </div>


    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
},
"search": false
});
});
</script>

</body>

</html>
